#----------------------------------------------------------
# Copyright 2017 University of Oxford
# Written by Michael A. Boemo (michael.boemo@path.ox.ac.uk)
# This software is licensed under GPL-3.0.  You should have
# received a copy of the license with this software.  If
# not, please Email the author.
#----------------------------------------------------------


#rejigs an ONT 5mer model or 6mer model to use the values from Osiris fixedPos, which lets us run eventalign for analogues

import sys


#--------------------------------------------------------------------------------------------------------------------------------------
class arguments:
	pass


#--------------------------------------------------------------------------------------------------------------------------------------
def splashHelp():
	s = """for_nanopolish.py: reformats nanopolish model files.
To run for_nanopolish.py, do:
  python for_nanopolish.py [arguments]
Example:
  python for_nanopolish.py -m /path/to/ONTmodel.model -tr /path/to/fixedPosOut.trained -p 80,86 -k 5
Required arguments are:
  -m,--model                path to model file to modify,
  -k                        length of kmer (5 or 6),
  -tr,--trained             path to .trained file from Osiris fixedPos,
  -o,--output               path to new model file with substituted kmers,
  -p,--positions            positions of analogues indexed from 0."""

	print s
	exit(0)


#--------------------------------------------------------------------------------------------------------------------------------------
def parseArguments(args):

	a = arguments()

	for i, argument in enumerate(args):
		if argument == '-m' or argument == '--model':
			a.model = str(args[i+1])
			
		elif argument == '-tr' or argument == '--trained':
			a.trained = str(args[i+1])

		elif argument == '-k':
			a.k = int(args[i+1])

		elif argument == '-p' or argument == '--positions':
			a.positions = map(int,str(args[i+1]).split(','))

		elif argument == '-o' or argument == '--output':
			a.out = str(args[i+1])

		elif argument == '-h' or argument == '--help':
			splashHelp()

	return a


#--------------------------------------------------------------------------------------------------------------------------------------
def import_poreModel(filename):
#	takes the filename of an ONT pore model file and returns a map from kmer (string) to [mean,std] (list of floats)
#	ARGUMENTS
#       ---------
#	- filename: path to an ONT model file
#	  type: string
#	OUTPUTS
#       -------
#	- kmer2MeanStd: a map, keyed by a kmer, that returns the model mean and standard deviation signal for that kmer
#	  type: dictionary

	f = open(filename,'r')
	g = f.readlines()
	f.close()

	kmer2MeanStd = {}
	for line in g:
		if line[0] != '#' and line[0:4] != 'kmer': #ignore the header
			splitLine = line.split('\t')
			kmer2MeanStd[ splitLine[0] ] = [ float(splitLine[1]), float(splitLine[2]), float(splitLine[3]), float(splitLine[4]), float(splitLine[5]) ]
	g = None

	return kmer2MeanStd


#--------------------------------------------------------------------------------------------------------------------------------------
def export_poreModel(emissions, outputFilename):
#	takes a dictionary of emissions produced by trainForAnalogue in train.py and outputs an ONT-style pore model file
#	ARGUMENTS
#       ---------
#	- emissions: keyed by a kmer string, outputs a list with kmer mean and standard deviation (generated by trainForAnalogue)
#	  type: dictionary
#	- outputFilename: path to the model file that should be created
#	  type: string
#	OUTPUTS
#       -------
#	- a model file is written to the directory specified

	#open the model file to write on
	f = open(outputFilename, 'w')

	#write kmer entries
	for key in emissions:
		toWrite = key+'\t'+str(emissions[key][0])+'\t'+str(emissions[key][1])+'\t'+str(emissions[key][2])+'\t'+str(emissions[key][3])+'\t'+str(emissions[key][4])+'\n'
		f.write(toWrite)

	#close the model file
	f.close()


#--------------------------------------------------------------------------------------------------------------------------------------
def import_trainedFile(filename,positions,k):
	
	f = open(filename,'r')
	g = f.readlines()
	f.close()

	#rescale
	for i,pos in enumerate(positions):
		positions[i] = pos-5

	analogueSignals = {}
	record = False
	start = 0
	for i,line in enumerate(g[1:]):
		splitLine = line.rstrip().split('\t')
		pos = int(splitLine[0].split('_')[0])
		if pos in positions:
			record = True
			start = i

		if record:
			if k == 6:
				analogueSignals[splitLine[1]] = [ float(splitLine[3]), float(splitLine[5]), 0.0, 0.0, 0.0 ]

			elif k == 5:
				analogueSignals[splitLine[1][1:]] = [ float(splitLine[3]), float(splitLine[5]), 0.0, 0.0, 0.0 ]
		
			else:
				print "Invalid value passed to -k argument."
				exit(0)

		if i == start+5 and record == True:
			record = False

	return analogueSignals


#MAIN--------------------------------------------------------------------------------------------------------------------------------------
args = sys.argv
a = parseArguments(args)

#load files
trainedFile = import_trainedFile(a.trained,a.positions,a.k)
model = import_poreModel(a.model)

#replace in model file
for key in trainedFile:
	model[key] = trainedFile[key]

#make a new model file
export_poreModel(model, a.out)



		

